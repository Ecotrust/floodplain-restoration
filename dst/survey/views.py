from rest_framework import viewsets
from rest_framework import renderers
from rest_framework import permissions
from rest_framework.decorators import link
from rest_framework.response import Response
from django.http import HttpResponse, HttpResponseForbidden

from survey.models import GravelSite, Pit, InputNode, Question, Context, QuestionCategory
from survey import serializers
from survey.permissions import IsOwnerOrShared
from flatblocks.models import FlatBlock
from django.db.models import Q

from django.template import RequestContext
from django.shortcuts import render_to_response
from django.contrib.admin.views.decorators import staff_member_required


class GravelSiteViewSet(viewsets.ModelViewSet):

    """
    This viewset automatically provides `list`, `create`, `retrieve`,
    `update` and `destroy` actions.

    Additionally we also provide an extra `highlight` action.
    """
    #queryset = GravelSite.objects.all()
    model = GravelSite

    def get_queryset(self):
        if self.request.user.id:
            return GravelSite.objects.filter(Q(user=self.request.user) | Q(shared_with_public=True))
        else:
            return GravelSite.objects.filter(shared_with_public=True)
    serializer_class = serializers.GravelSiteSerializer
    permission_classes = (
        permissions.IsAuthenticatedOrReadOnly,
        IsOwnerOrShared,
    )

    @link(renderer_classes=[renderers.JSONRenderer])
    def status(self, request, *args, **kwargs):
        obj = self.get_object()
        return Response(obj.status)

    @link(renderer_classes=[renderers.JSONRenderer])
    def suitability(self, request, *args, **kwargs):
        obj = self.get_object()
        return Response(obj.suitability)

    def pre_save(self, obj):
        obj.user = self.request.user


class PitViewSet(viewsets.ModelViewSet):

    """Pits """
    #queryset = Pit.objects.all()
    model = Pit

    def get_queryset(self):
        if self.request.user.id:
            return Pit.objects.filter(Q(user=self.request.user) | Q(site__shared_with_public=True))
        else:
            return Pit.objects.filter(site__shared_with_public=True)

    serializer_class = serializers.PitSerializer
    permission_classes = (
        permissions.IsAuthenticatedOrReadOnly,
        IsOwnerOrShared,
    )

    def pre_save(self, obj):
        obj.user = self.request.user


class InputNodeViewSet(viewsets.ModelViewSet):

    """InputNode """
    model = InputNode
    filter_fields = ('site',)
    serializer_class = serializers.InputNodeSerializer
    permission_classes = (
        permissions.IsAuthenticatedOrReadOnly,
        IsOwnerOrShared,
    )

    def get_queryset(self):
        if self.request.user.id:
            return InputNode.objects.filter(Q(user=self.request.user) | Q(site__shared_with_public=True))
        else:
            return InputNode.objects.filter(site__shared_with_public=True)

    def pre_save(self, obj):
        obj.user = self.request.user


class QuestionViewSet(viewsets.ReadOnlyModelViewSet):

    """Questions (Read only)"""
    queryset = Question.objects.all().order_by('order')
    serializer_class = serializers.QuestionSerializer


class FlatblockSet(viewsets.ReadOnlyModelViewSet):

    """Flatblock (Read only)"""
    model = FlatBlock
    filter_fields = ('slug', 'header', 'content')
    queryset = FlatBlock.objects.all().order_by('header')
    serializer_class = serializers.FlatBlockSerializer


def auth(request):
    baseurl = request.get_host()
    username = None
    isadmin = False
    if request.user and request.user.is_authenticated():
        username = request.user.username
        if request.user.is_staff:
            isadmin = True

    template = """'use strict';
// Generated by django
angular
  .module('uiApp').run(function($rootScope){{
    $rootScope.userName = '{0}';
    $rootScope.baseUrl = '{1}'; // no trailing slash
    $rootScope.isAdmin = '{2}';
  }});
    """

    if username:
        content = template.format(username, baseurl, isadmin)
    else:
        content = template.format('', baseurl, isadmin)

    return HttpResponse(content, status=200, content_type="application/javascript")


class ContextSet(viewsets.ReadOnlyModelViewSet):
    """Contexts (Read only)"""
    model = Context
    filter_fields = ('name', 'order')
    queryset = Context.objects.all().order_by('order')
    serializer_class = serializers.ContextSerializer

class QuestionCategorySet(viewsets.ReadOnlyModelViewSet):
    """Question Categories (Read only)"""
    model = QuestionCategory
    filter_fields = ('name', 'context', 'order')
    queryset = QuestionCategory.objects.all().order_by('context__order', 'order')
    serializer_class = serializers.QuestionCategorySerializer

def build_cpt_dict(cpt, given, variables):
    cpt_list = []
    cond_dict = {}
    cond_list = []  #this will retain the order

    for cond in cpt:
        cond_value = cpt[cond]
        cond_id = ""
        for idx, val in enumerate(cond[0:len(cond)-1]):
            cond_id += str(given[idx][1].index(val))
        if cond_id not in cond_dict.keys():
            cond_dict[cond_id] = {
                'condition': [x for x in cond[0:len(cond)-1]],
                'values':[],
                'val_dict': {},
                'cond_id': cond_id
            }
            cond_list.append(cond_id)
        cond_dict[cond_id]['val_dict'][str(variables.index(cond[len(cond)-1]))] = cond_value
    for cond_id_key in cond_dict.keys():
        cond_id = cond_dict[cond_id_key]
        for idx in range(0,len(cond_id['val_dict'])):
            cond_id['values'].append(cond_id['val_dict'][str(idx)])
        cond_id.pop("val_dict",None)

    cond_list.sort()
    for cond_id in cond_list:
        cpt_list.append(cond_dict[cond_id])

    return cpt_list


# create dict where keys are tiers, and each tier has keys of nodes
def sort_bbn_nodes():
    from bbn import BeliefNetwork
    from dst import settings as dst_settings
    from copy import copy, deepcopy
    BBN = BeliefNetwork.from_bif(dst_settings.BBN_BIF)

    blank_node = {
        'cpt': {},
        'parents': [],
        'given': [],
        'variables': [],
        'tier': None
    }

    node_dict = {}
    sorted_dict = {
        '0': {}
    }
    for node_idx in BBN.probabilities:
        node = BBN.probabilities[node_idx]
        if not node_idx in node_dict.keys():
            node_dict[node_idx] = deepcopy(blank_node)
        node_dict[node_idx]['variables'] = BBN.variables[node_idx]
        if node['given']:
            node_givens = [(x, BBN.variables[x]) for x in node['given']]
        else:
            node_givens = []
        node_dict[node_idx]['cpt'] = build_cpt_dict(node['cpt'], node_givens, BBN.variables[node_idx])

        if node['given']:
            node_dict[node_idx]['given'] = node['given']

        for given_idx in node_dict[node_idx]['given']:
            if not given_idx in node_dict.keys():
                node_dict[given_idx] = deepcopy(blank_node)
            node_dict[given_idx]['parents'].append(node_idx)

    unsorted_nodes = node_dict.keys()
    while len(unsorted_nodes) > 0:
        unsorted_list = [x for x in unsorted_nodes]
        for node_idx in unsorted_nodes:
            if len(node_dict[node_idx]['parents']) == 0:
                node_dict[node_idx]['tier'] = 0
                unsorted_list.remove(node_idx)
                sorted_dict['0'][node_idx] = node_dict[node_idx]
            else:
                for parent_idx in node_dict[node_idx]['parents']:
                    if not node_dict[node_idx]['tier']:
                        if not node_dict[parent_idx]['tier'] == None:
                            node_tier = node_dict[parent_idx]['tier']+1
                            node_dict[node_idx]['tier'] = node_tier
                            unsorted_list.remove(node_idx)
                            if not str(node_tier) in sorted_dict.keys():
                                sorted_dict[str(node_tier)] = {}
                            sorted_dict[str(node_tier)][node_idx] = node_dict[node_idx]

        unsorted_nodes = unsorted_list

    return sorted_dict

# connect nodes with children in a single, recursive dict
def get_node_dict(tier, node_idx, nodes):
    node = nodes[tier][node_idx]
    node['children'] = []
    node['cpt'] = node['cpt']
    for idx, input_node in enumerate(node['given']):
        node['children'].append({
            "name": input_node,
            "dict": get_node_dict(str(int(tier)+1), input_node, nodes)
        })

    return node

# return a dict of all bbn nodes maintaining familial hierarchy
def get_bbn_nodes():
    top_tier = '0'
    sorted_nodes = sort_bbn_nodes()
    bbn_nodes = []
    for node in sorted_nodes[top_tier]:
        bbn_nodes.append({
            'name': node,
            'dict': get_node_dict(top_tier, node, sorted_nodes)
        })

    return bbn_nodes


def edit_bbn(self, request, extra_context=None):
    from survey.models import BifSettings
    from django.contrib.admin.options import ModelAdmin
    # opts = self.model._meta
    # admin_site = self.admin_site
    # has_perm = request.user.has_perm(opts.app_label + '.' + opts.get_change_permission())

    bifsets = BifSettings.objects.all()
    self.change_list_template = "admin/survey/bifsettings/change_list.html"
    return ModelAdmin.changelist_view (self, request, extra_context)

edit_bbn = staff_member_required(edit_bbn)

def admin_change_form(self, request, object_id, form_url='', extra_context={}):
    from django.contrib.admin.options import ModelAdmin
    import json
    self.change_form_template = "admin/survey/bifsettings/change_form.html"
    # import ipdb; ipdb.set_trace()
    extra_context['bbn_str'] = json.dumps(get_bbn_nodes())
    extra_context['bbn_settings'] = get_bbn_nodes()
    return ModelAdmin.change_view(self, request, object_id, form_url, extra_context)
# admin_change_form = staff_member_required(admin_change_form)
### Uncommenting this causes a 'ModelAdmin' object has no attribute 'User' error
### However, no one can access this without staff and superuser privs, so it's okay.

def admin_add_form(self, request, form_url='', extra_context=None):
    from django.contrib.admin.options import ModelAdmin
    self.add_form_template = "admin/survey/bifsettings/change_form.html"
    return ModelAdmin.add_view(self, request, form_url, extra_context)
# admin_add_form = staff_member_required(admin_add_form)
